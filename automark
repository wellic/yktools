#!/bin/bash
#=======================================================================================================================
# Description
#   Script for automated watermarking and uploading photos to Google Photos
# Requires
#   ImageMagick
#   webp (apt install webp) for WebP support
#   gphotos-uploader-cli (https://github.com/gphotosuploader/gphotos-uploader-cli)
# Synopsis
#   automark [options] picture_dir
#=======================================================================================================================

. "$(dirname "$(realpath "$0")")/common.sh"

# Setup vars
pic_size=1600                                                      # Max size of the pictures to upload
file_watermark_white="$HOME/Pictures/Misc/dk-watermark-white.png"  # Default watermark file
file_watermark_black="$HOME/Pictures/Misc/dk-watermark-black.png"  # Black watermark file
file_watermark_small="$HOME/Pictures/Misc/dk-watermark-small.png"  # 'Small' watermark file
dir_upload="$HOME/tmp/gphoto-upload"                               # Path that gphotos-uploader-cli is configured to upload from
USAGE_INFO="Usage: $0 [options] photos_dir
Options:
  -B  Do not add a black border to the image
  -D  Do not delete the $dir_upload directory after processing
  -P  Do not convert to WebP
  -R  Do not resize photos to $pic_size pixels
  -U  Do not upload the photos (implies -D)
  -W  Do not watermark images
  -b  Use black watermark instead of the default white one
  -d  Delete original (after successful processing)
  -s  Use "small" watermark instead of the default one (better for small images)

gphotos-uploader-cli must be configured to use $dir_upload unless -U is specified."

#-----------------------------------------------------------------------------------------------------------------------
# Functions
#-----------------------------------------------------------------------------------------------------------------------

# Prints out a status message (overwritten every time)
# Arguments:
#   $1 message text
status() {
    # Pad/truncate the line to fit screen width
    printf "%-${tty_width}.${tty_width}s\r" "$1"
}

# Prints out a progress message
# Arguments:
#   $1 current item number
#   $2 total number of items
#   $3 message text
progress() {
    printf -v msg '[%d/%d] %s' "$1" "$2" "$3"
    status "$msg"
}

# Fetches image details using its metadata. Return success/error code
# Arguments:
#   $1 image file name
fetch_image_details() {
    # Fetch image size
    img_size=$(identify -quiet -format "%w %h" "$1" | awk '{print ($1>$2 ? $1 : $2)}') || warn "Determining image size in $1 failed."
    # Fetch image caption (dataset 2, property 105, see http://www.imagemagick.org/script/escape.php for details)
    img_caption=$(identify -quiet -format "%[IPTC:2:105]" "$1") || warn "Determining image caption in $1 failed."
}

#=======================================================================================================================
# Main routine
#=======================================================================================================================

# Trap Ctrl-C
trap interrupted INT

#-----------------------------------------------------------------------------------------------------------------------
# Parse and check the command line
#-----------------------------------------------------------------------------------------------------------------------

# Parse command line options
b_delete_upload_dir=1
b_delete_original=0
b_webp=1
b_resize=1
b_watermark=1
b_upload=1
s_watermark_to_use="$file_watermark_white"
s_border_options="-bordercolor black -border 2"

args=$(getopt -o BDPRUWbds -- "$@")
[ $? -ne 0 ] && usage
eval set -- $args
for i; do
    case "$i" in
        -B)
            unset s_border_options
            shift
            ;;
        -D)
            b_delete_upload_dir=0
            shift
            ;;
        -P)
            b_webp=0
            shift
            ;;
        -R)
            b_resize=0
            shift
            ;;
        -U)
            b_delete_upload_dir=0
            b_upload=0
            shift
            ;;
        -W)
            b_watermark=0
            shift
            ;;
        -b)
            s_watermark_to_use="$file_watermark_black"
            shift
            ;;
        -d)
            b_delete_original=1
            shift
            ;;
        -s)
            s_watermark_to_use="$file_watermark_small"
            shift
            ;;
        --)
            shift;
            break
            ;;
    esac
done

# Parse the rest of the command line
dir_photos="$1"

# Check photos_dir
[[ -n "$dir_photos" ]] || usage "Directory for photos is not specified"
[[ -d "$dir_photos" ]] || err "Directory '$dir_photos' does not exist."

#-----------------------------------------------------------------------------------------------------------------------
# Initialization
#-----------------------------------------------------------------------------------------------------------------------

# Make sure target dir created
mkdir -p "$dir_upload" || err "Failed to create target directory $dir_upload"

# Get TTY width
tty_width=$(stty size | cut -d ' ' -f 2)

#-----------------------------------------------------------------------------------------------------------------------
# Read the file list
#-----------------------------------------------------------------------------------------------------------------------

# Temporarily change the field separator to make find results work with filenames containing spaces
OLDIFS=$IFS
IFS=$'\n'

# Get the files
files=( $(find "$dir_photos" -type f \( -iname '*.jpg' -o -iname '*.png' -o -iname '*.webp' \) ! -name '*.w.*' -print | sort) )

# Restore the field separator
IFS=$OLDIFS

i_count=${#files[@]}

#-----------------------------------------------------------------------------------------------------------------------
# Process the picture files
#-----------------------------------------------------------------------------------------------------------------------

# Iterate through the file list
i_cur_num=0
i_err_count=0
for (( i_cur_num=1; i_cur_num<=${i_count}; i_cur_num++ )); do
    src_file=${files[$((i_cur_num-1))]}
    b_error=0

    # Determine full output file name
    src_file_name=$(basename "$src_file")
    src_extension="$(echo ${src_file##*.} | tr '[:upper:]' '[:lower:]')"
    if [[ $b_webp -eq 0 ]]; then
        dst_extension="$src_extension"
    else
        dst_extension=webp
    fi
    dst_file="$dir_upload/${src_file_name%\.*}.w.$dst_extension"

    # Create a temporary PNG file for processing
    tmp_file="$(mktemp).png"

    # Print out status message
    progress $i_cur_num $i_count "Processing $src_file"

    # Try to fetch image details
    fetch_image_details "$src_file"

    # Determine the need for resize. We resize unless it's turned off, and only if picture size is unknown or bigger than
    # the standard size
    unset s_resize_flags
    [[ $b_resize -ne 0 ]] && ( [[ -z "$img_size" ]] || [[ $img_size -gt $pic_size ]] ) && s_resize_flags="-resize $pic_size"

    # Resize and autorotate the image, add a border if needed
    if ! convert $s_resize_flags -quiet -quality 90 -auto-orient $s_border_options "$src_file" "$tmp_file"; then
        b_error=1
        warn "Conversion of $src_file failed."

    # Apply watermark
    elif ! ( [[ $b_watermark -eq 0 ]] || composite -blend 90% -gravity southeast "$s_watermark_to_use" "$tmp_file" "$tmp_file" ); then
        b_error=1
        warn "Watermarking $src_file failed."

    # If successfully processed
    else
        # If the format stays PNG, just move the created file into the final destination
        if [[ "$dst_extension" == "png" ]]; then
            mv "$tmp_file" "$dst_file" || (b_error=1 && warn "Failed to move $tmp_file to $dst_file")
        # Otherwise convert it to the target format
        else
            convert "$tmp_file" "$dst_file" || (b_error=1 && warn "Failed to convert $tmp_file into $dst_file")
        fi
    fi

    # If processing succeeded
    if [[ $b_error -eq 0 ]]; then
        # Delete the original if needed
        [[ $b_delete_original -ne 0 ]] && (rm -f "$src_file" || warn "Couldn't delete $src_file")

    # Otherwise add the picture to the failure list
    else
        failed_pics[$i_err_count]="$src_file"
        ((i_err_count++))
    fi

    # Remove temp file
    rm -f "$tmp_file"
done

#-----------------------------------------------------------------------------------------------------------------------
if [[ $b_upload -ne 0 ]]; then
    # If there was no error, upload the processed pictures
    if [[ $i_err_count -eq 0 ]]; then
        gphotos-uploader-cli
        rc=$?
        [[ $rc -eq 0 ]] || warn "gphotos-uploader-cli exited with code $rc"

    # Print out failure list otherwise
    else
        warn "There were errors processing following pictures:"
        for f in ${failed_pics[@]}; do echo "$f" >&2; done
        warn "Uploading skipped"
    fi
fi

#-----------------------------------------------------------------------------------------------------------------------
# Finalization
#-----------------------------------------------------------------------------------------------------------------------

status "Done. $i_count files processed."
echo

# Remove upload dir if needed
[[ $b_delete_upload_dir -ne 0 ]] && rm -rf "$dir_upload"

[[ $i_err_count -gt 0 ]] && exit 1

exit 0
